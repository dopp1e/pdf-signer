@inreference{AESGCMSIV2025,
  title = {{{AES-GCM-SIV}}},
  booktitle = {Wikipedia},
  date = {2025-01-08T12:58:08Z},
  url = {https://en.wikipedia.org/w/index.php?title=AES-GCM-SIV&oldid=1268171674},
  urldate = {2025-04-18},
  abstract = {AES-GCM-SIV is a mode of operation for the Advanced Encryption Standard which provides similar (but slightly worse) performance to Galois/Counter Mode as well as misuse resistance in the event of the reuse of a cryptographic nonce. The construction is defined in RFC 8452.},
  langid = {english},
  annotation = {Page Version ID: 1268171674},
  file = {/home/doppie/Zotero/storage/JPTSA5LC/AES-GCM-SIV.html}
}

@online{alvinashcraftCNGFeaturesWin32,
  title = {{{CNG Features}} - {{Win32}} Apps},
  author = {{alvinashcraft}},
  url = {https://learn.microsoft.com/en-us/windows/win32/seccng/cng-features},
  urldate = {2025-04-18},
  abstract = {CNG has the following features.},
  langid = {american},
  file = {/home/doppie/Zotero/storage/NRFWE9GX/cng-features.html}
}

@inreference{CarmichaelFunction2025,
  title = {Carmichael Function},
  booktitle = {Wikipedia},
  date = {2025-03-07T22:40:54Z},
  url = {https://en.wikipedia.org/w/index.php?title=Carmichael_function&oldid=1279333007},
  urldate = {2025-04-18},
  abstract = {In number theory, a branch of mathematics, the Carmichael function  λ(n) of a positive integer  n is the smallest positive integer m such that                                   a                        m                             ≡         1                               (           mod                      n           )                          \{\textbackslash displaystyle a\textasciicircum\{m\}\textbackslash equiv 1\{\textbackslash pmod \{n\}\}\}    holds for every integer  a coprime to  n. In algebraic terms,  λ(n) is the exponent of the multiplicative group of integers modulo  n. As this is a finite abelian group, there must exist an element whose order equals the exponent,  λ(n). Such an element is called a primitive  λ-root modulo  n. The Carmichael function is named after the American mathematician Robert Carmichael who defined it in 1910. It is also known as Carmichael's λ function, the reduced totient function, and the least universal exponent function. The order of the multiplicative group of integers modulo  n is  φ(n), where  φ is Euler's totient function. Since the order of an element of a finite group divides the order of the group,  λ(n) divides  φ(n). The following table compares the first 36 values of  λ(n) (sequence A002322 in the OEIS) and  φ(n) (in bold if they are different; the  ns such that they are different are listed in OEIS: A033949).},
  langid = {english},
  annotation = {Page Version ID: 1279333007},
  file = {/home/doppie/Zotero/storage/5AYM6CUS/Carmichael_function.html}
}

@video{computerphilePrimeNumbersRSA2021,
  entrysubtype = {video},
  title = {Prime {{Numbers}} \& {{RSA Encryption Algorithm}} - {{Computerphile}}},
  editor = {{Computerphile}},
  editortype = {director},
  date = {2021},
  url = {https://www.youtube.com/watch?v=JD72Ry60eP4},
  urldate = {2025-04-18}
}

@inreference{GaloisCounterMode2025,
  title = {Galois/{{Counter Mode}}},
  booktitle = {Wikipedia},
  date = {2025-03-24T20:21:42Z},
  url = {https://en.wikipedia.org/w/index.php?title=Galois/Counter_Mode&oldid=1282175091},
  urldate = {2025-04-18},
  abstract = {In cryptography, Galois/Counter Mode (GCM) is a mode of operation for symmetric-key cryptographic block ciphers which is widely adopted for its performance. GCM throughput rates for state-of-the-art, high-speed communication channels can be achieved with inexpensive hardware resources.  The GCM algorithm provides both data authenticity (integrity) and confidentiality and belongs to the class of authenticated encryption with associated data (AEAD) methods. This means that as input it takes a key K, some plaintext P, and some associated data AD; it then encrypts the plaintext using the key to produce ciphertext C, and computes an authentication tag T from the ciphertext and the associated data (which remains unencrypted). A recipient with knowledge of K, upon reception of AD, C and T, can decrypt the ciphertext to recover the plaintext P and can check the tag T to ensure that neither ciphertext nor associated data were tampered with. GCM uses a block cipher with block size 128 bits (commonly AES-128) operated in counter mode for encryption, and uses arithmetic in the Galois field GF(2128) to compute the authentication tag; hence the name. Galois Message Authentication Code (GMAC) is an authentication-only variant of the GCM which can form an incremental message authentication code. Both GCM and GMAC can accept initialization vectors of arbitrary length. Different block cipher modes of operation can have significantly different performance and efficiency characteristics, even when used with the same block cipher. GCM can take full advantage of parallel processing and implementing GCM can make efficient use of an instruction pipeline or a hardware pipeline. By contrast, the cipher block chaining (CBC) mode of operation incurs pipeline stalls that hamper its efficiency and performance.},
  langid = {english},
  annotation = {Page Version ID: 1282175091},
  file = {/home/doppie/Zotero/storage/CGJV5ZFD/Counter_Mode.html}
}

@report{gueronAESGCMSIVNonceMisuseResistant2019,
  type = {Request for Comments},
  title = {{{AES-GCM-SIV}}: {{Nonce Misuse-Resistant Authenticated Encryption}}},
  shorttitle = {{{AES-GCM-SIV}}},
  author = {Gueron, Shay and Langley, Adam and Lindell, Yehuda},
  date = {2019-04},
  number = {RFC 8452},
  institution = {Internet Engineering Task Force},
  doi = {10.17487/RFC8452},
  url = {https://datatracker.ietf.org/doc/rfc8452},
  urldate = {2025-04-18},
  abstract = {This memo specifies two authenticated encryption algorithms that are nonce misuse resistant – that is, they do not fail catastrophically if a nonce is repeated. This document is the product of the Crypto Forum Research Group.},
  pagetotal = {42},
  file = {/home/doppie/Zotero/storage/XEL5P29J/Gueron et al. - 2019 - AES-GCM-SIV Nonce Misuse-Resistant Authenticated Encryption.pdf}
}

@report{housleyCryptographicMessageSyntax2009,
  type = {Request for Comments},
  title = {Cryptographic {{Message Syntax}} ({{CMS}})},
  author = {Housley, Russ},
  date = {2009-09},
  number = {RFC 5652},
  institution = {Internet Engineering Task Force},
  doi = {10.17487/RFC5652},
  url = {https://datatracker.ietf.org/doc/rfc5652},
  urldate = {2025-04-19},
  abstract = {This document describes the Cryptographic Message Syntax (CMS). This syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content. [STANDARDS-TRACK]},
  pagetotal = {56},
  file = {/home/doppie/Zotero/storage/EB5SA3RA/Housley - 2009 - Cryptographic Message Syntax (CMS).pdf}
}

@online{incognitoRandDevUrandom2016,
  type = {Forum post},
  title = {Is a Rand from /Dev/Urandom Secure for a Login Key?},
  author = {Incognito},
  date = {2016-08-26},
  url = {https://security.stackexchange.com/q/3936},
  urldate = {2025-04-18},
  organization = {Information Security Stack Exchange},
  file = {/home/doppie/Zotero/storage/TKP9M5CA/is-a-rand-from-dev-urandom-secure-for-a-login-key.html}
}

@online{OsMiscellaneousOperating,
  title = {Os — {{Miscellaneous}} Operating System Interfaces},
  url = {https://docs.python.org/3/library/os.html},
  urldate = {2025-04-18},
  abstract = {Source code: Lib/os.py This module provides a portable way of using operating system dependent functionality. If you just want to read or write a file see open(), if you want to manipulate paths, s...},
  langid = {english},
  organization = {Python documentation},
  file = {/home/doppie/Zotero/storage/5Y9DED63/os.html}
}

@online{porninAnswerRandDev2011,
  title = {Answer to "{{Is}} a Rand from /Dev/Urandom Secure for a Login Key?"},
  shorttitle = {Answer to "{{Is}} a Rand from /Dev/Urandom Secure for a Login Key?},
  author = {Pornin, Thomas},
  date = {2011-05-18},
  url = {https://security.stackexchange.com/a/3939},
  urldate = {2025-04-18},
  organization = {Information Security Stack Exchange},
  file = {/home/doppie/Zotero/storage/RTLLAPK2/is-a-rand-from-dev-urandom-secure-for-a-login-key.html}
}

@inreference{PrivacyEnhancedMail2025,
  title = {Privacy-{{Enhanced Mail}}},
  booktitle = {Wikipedia},
  date = {2025-03-12T09:58:10Z},
  url = {https://en.wikipedia.org/w/index.php?title=Privacy-Enhanced_Mail&oldid=1280073904},
  urldate = {2025-04-18},
  abstract = {Privacy-Enhanced Mail (PEM) is a de facto file format for storing and sending cryptographic keys, certificates, and other data, based on a set of 1993 IETF standards defining "privacy-enhanced mail." While the original standards were never broadly adopted and were supplanted by PGP and S/MIME, the textual encoding they defined became very popular. The PEM format was eventually formalized by the IETF in RFC 7468.},
  langid = {english},
  annotation = {Page Version ID: 1280073904},
  file = {/home/doppie/Zotero/storage/NNB7PXGU/Privacy-Enhanced_Mail.html}
}

@online{PyhankosignvalidationPackagePyHanko,
  title = {Pyhanko.Sign.Validation Package — {{pyHanko}} 0.26.1.Dev1 Documentation},
  url = {https://pyhanko.readthedocs.io/en/latest/api-docs/pyhanko.sign.validation.html#pyhanko.sign.validation.status.SignatureStatus.valid},
  urldate = {2025-04-19},
  file = {/home/doppie/Zotero/storage/38WPDAWG/pyhanko.sign.validation.html}
}

@article{rivestMethodObtainingDigital1978,
  title = {A Method for Obtaining Digital Signatures and Public-Key Cryptosystems},
  author = {Rivest, R. L. and Shamir, A. and Adleman, L.},
  date = {1978-02-01},
  journaltitle = {Commun. ACM},
  volume = {21},
  number = {2},
  pages = {120--126},
  issn = {0001-0782},
  doi = {10.1145/359340.359342},
  url = {https://dl.acm.org/doi/10.1145/359340.359342},
  urldate = {2025-04-18},
  abstract = {An encryption method is presented with the novel property that publicly revealing an encryption key does not thereby reveal the corresponding decryption key. This has two important consequences: (1) Couriers or other secure means are not needed to transmit keys, since a message can be enciphered using an encryption key publicly revealed by the intented recipient. Only he can decipher the message, since only he knows the corresponding decryption key. (2) A message can be “signed” using a privately held decryption key. Anyone can verify this signature using the corresponding publicly revealed encryption key. Signatures cannot be forged, and a signer cannot later deny the validity of his signature. This has obvious applications in “electronic mail” and “electronic funds transfer” systems. A message is encrypted by representing it as a number M, raising M to a publicly specified power e, and then taking the remainder when the result is divided by the publicly specified product, n, of two large secret primer numbers p and q. Decryption is similar; only a different, secret, power d is used, where e * d ≡ 1(mod (p - 1) * (q - 1)). The security of the system rests in part on the difficulty of factoring the published divisor, n.},
  file = {/home/doppie/Zotero/storage/DHHWW536/Rivest et al. - 1978 - A method for obtaining digital signatures and public-key cryptosystems.pdf}
}

@inreference{RSACryptosystem2025,
  title = {{{RSA}} Cryptosystem},
  booktitle = {Wikipedia},
  date = {2025-04-09T09:48:20Z},
  url = {https://en.wikipedia.org/w/index.php?title=RSA_cryptosystem&oldid=1284724493#Key_generation},
  urldate = {2025-04-18},
  abstract = {The RSA (Rivest–Shamir–Adleman) cryptosystem is a public-key cryptosystem, one of the oldest widely used for secure data transmission. The initialism "RSA" comes from the surnames of Ron Rivest, Adi Shamir and Leonard Adleman, who publicly described the algorithm in 1977. An equivalent system was developed secretly in 1973 at Government Communications Headquarters (GCHQ), the British signals intelligence agency, by the English mathematician Clifford Cocks. That system was declassified in 1997. In a public-key cryptosystem, the encryption key is public and distinct from the decryption key, which is kept secret (private). An RSA user creates and publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers are kept secret. Messages can be encrypted by anyone, via the public key, but can only be decrypted by someone who knows the private key. The security of RSA relies on the practical difficulty of factoring the product of two large prime numbers, the "factoring problem". Breaking RSA encryption is known as the RSA problem. Whether it is as difficult as the factoring problem is an open question. There are no published methods to defeat the system if a large enough key is used. RSA is a relatively slow algorithm. Because of this, it is not commonly used to directly encrypt user data. More often, RSA is used to transmit shared keys for symmetric-key cryptography, which are then used for bulk encryption–decryption.},
  langid = {english},
  annotation = {Page Version ID: 1284724493},
  file = {/home/doppie/Zotero/storage/6T63TL6W/RSA_cryptosystem.html}
}

@article{woodsDataSecurityApple2024,
  title = {Data {{Security}} in the {{Apple Ecosystem}}: {{An Evaluation}}},
  shorttitle = {Data {{Security}} in the {{Apple Ecosystem}}},
  author = {Woods, Kayrene},
  date = {2024-11-26},
  journaltitle = {Cybersecurity Undergraduate Research Showcase},
  url = {https://digitalcommons.odu.edu/covacci-undergraduateresearch/2024fall/projects/11},
  file = {/home/doppie/Zotero/storage/NBXQ4H48/11.html}
}

@inreference{X5092025,
  title = {X.509},
  booktitle = {Wikipedia},
  date = {2025-04-08T06:02:17Z},
  url = {https://en.wikipedia.org/w/index.php?title=X.509&oldid=1284531859},
  urldate = {2025-04-19},
  abstract = {In cryptography, X.509 is an International Telecommunication Union (ITU) standard defining the format of public key certificates. X.509 certificates are used in many Internet protocols, including TLS/SSL, which is the basis for HTTPS, the secure protocol for browsing the web. They are also used in offline applications, like electronic signatures. An X.509 certificate binds an identity to a public key using a digital signature. A certificate contains an identity (a hostname, or an organization, or an individual) and a public key (RSA, DSA, ECDSA, ed25519, etc.), and is either signed by a certificate authority or is self-signed. When a certificate is signed by a trusted certificate authority, or validated by other means, someone holding that certificate can use the public key it contains to establish secure communications with another party, or validate documents digitally signed by the corresponding private key. X.509 also defines certificate revocation lists, which are a means to distribute information about certificates that have been deemed invalid by a signing authority, as well as a certification path validation algorithm, which allows for certificates to be signed by intermediate CA certificates, which are, in turn, signed by other certificates, eventually reaching a trust anchor. X.509 is defined by the ITU's "Standardization Sector" (ITU-T's SG17), in ITU-T Study Group 17 and is based on Abstract Syntax Notation One (ASN.1), another ITU-T standard.},
  langid = {english},
  annotation = {Page Version ID: 1284531859},
  file = {/home/doppie/Zotero/storage/REM4BCJ2/X.html}
}
